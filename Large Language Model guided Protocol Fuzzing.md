# 摘要

本文构建了一个基于LLM引导的协议fuzz引擎，名为ChatAFL（根据AFL改的），CHATAFL为协议中的每个消息类型构造语法，然后通过与llm的交互改变消息或预测消息序列中的下一个消息。

# 介绍

协议实现基本是软件系统中安全性最为薄弱的一环。

对于协议的模糊测试最关键的一点就是要以正确的序列输入正确的输入（在某些协议中，即使是同样的输入也有可能产生两种完全不同的输出），然而在实际的情况下，我们很难去猜测出协议需要的正确的结构化输入，也很难预测出协议需要的输入序列

现有的变异导向的模糊器通过对已记录的消息序列来产生输入（为了保持协议中输入的结构性），简单的突变甚至只是单纯的改变输入的序列，这样的变异策略其有效性受制于这些已被记录的消息种子自身的质量和多样性，并且对提升输入空间以及状态空间的覆盖率并不是很有效

作者把LLM引导的协议测试列出了三个重要的组成部分

1. fuzzer通过LLM在结构化输入要求严格的协议输入中提取出机器可读的语法
2. fuzzer使用LLM来增加记录消息序列中用作初始种子的消息的多样性。
3. fuzzer使用 LLM 突破覆盖率的平台期，此时 LLM 会被提示生成消息以达到新的状态。

最后吹一下牛皮，说在广泛使用的协议中发现了9个不同且先前未知的漏洞

# 研究背景及动机

## Protocol Fuzzing

作者举了一个RFC2326的例子，也就是RTSP协议（tips：RTSP 是一个网络协议，专门设计用于控制音频或视频等多媒体流的传输，例如开始、暂停、停止和快进流媒体内容。本文也是用这个协议来做的实验），稍微讲了一下协议在当今互联网环境下的重要性（容易被RCE等等）

分析了一下RTSP协议消息的基本组成结构：

![image-20241028112050166](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20241028112050166.png)

以及在应用中其需要遵循的消息类型顺序：

![image-20241028112237670](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20241028112237670.png)

然后通过比较输入生成导向的fuzzer与变异导向的fuzzer来证明了选择变异导向的fuzzer的正确性，之后又分析了变异导向fuzzer所面临的挑战：

1. 对于初始种子的依赖性：提前记录好的种子难以覆盖待测协议巨大的输入空间以及状态空间
2. 未知的消息结构：由于对协议使用的消息结构体是未知的，所以在构建结构化输入方面存在困难
3. 未知的状态空间

## Large Language Models

分析了一下为什么LLM可以被用于生成对协议fuzz的输入，然后通过回答前面的三个挑战来引入实例研究（测试LLM对于引导protocol fuzz的可行性）

# LLM在protocol fuzz中可行性的研究

选择的实验对象是RTSP，选择的LLM是ChatGPT

## 提升消息语法：质量与多样性

作者为了检验LLM对于提取消息语法的能力，自己阅读了RFC2326的说明文档并人工提取出了它的具体语法（10种类型，每种大概由2到5消息头部字段组成）

其中PLAY消息的结构为，其中，某些类型的消息具有特定的标头字段：

![image-20241029110041601](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20241029110041601.png)

为了分析LLM对RTSP提取出的语法，我们随机选定50个LLM对RTSP产生的答案作为一个答案集。

使用LLM对这10种类型生成语法，预计这些消息类型会出现在LLM生成的40多个答案之中，如下：

![image-20241029111132544](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20241029111132544.png)

尽管生成的语法中有两种客户端的随机消息，比如SET DESCRIPTION，但是都只出现了一次

作者也检查了LLM生成语法的质量，在10种类型的消息中的9种，LLM产生的语法与作者人工提取出的语法完全相同。唯一的例外是对于PLAY的客户端请求，LLM在一些答案中忽略了**Range**字段。在后面更进一步的研究中，作者发现LLM仍然精准的生成了PLAY的语法，其中35个答案中准求生成了包含range语法，另外15个忽略range字段。

以上，可以认为LLM具有可以高精度生成消息语法的能力，可以用于指导变异算法

## 丰富种子语料库：多样性与有效性	

作者令LLM 为消息序列生成一个随机的消息。传统的初始种子集合通常只有4种类型的请求，缺失了剩余6种。然而传统编译策略要生成这剩余6种种子的可能性比较低，作者观察了现有的最先进的fuzzer AFLNET以及NSfuzz，这两者都未能生成缺失的那6种类型，因此初始种子序列是重要的。

为了研究LLM的能力，作者使用LLM对10种类型分别生成了10个消息，总共获得100条消息。之后检查了这些消息是否被正确的放置在一个给定消息序列的对应位置上。通过将这样一个构造好的消息序列发送给服务器，检查服务器的回显即可确定消息的内容以及消息的序列是否正确

实验结果显示LLM生成的消息序列有99%都是满足状态顺序的。接近55%的请求可以被服务器直接接收。不成功的测例中20.4%是由于Live555不支持RFC协议中的某些功能。剩下的测例是由于错误的回话ID，这个ID是由服务器动态分配，而LLM在生成消息时缺乏上下文语境。作者将这些ID替换为正确的ID后就可以被接收

作者提出了两种提升LLM生成正确ID能力的方式：

1. 将服务器的response作为prompt提供给LLM，使其生成相同类型的消息（也就是上下文环境？）
2. 将ID直接包含到给定的请求序列当中，LLM就可以正确的将这些ID插入到生成的消息中

**结论**：LLM能够生成准确的消息，并具有丰富初始种子的能力。

## 包含Interesting的状态转移

作者为LLM提供了fuzzer与服务器之间的消息交换，并要求LLM给出一个可能造成状态转换的消息。作者给LLM提供了现有的通信记录，这些记录可以使服务器到达每一种状态。

![image-20241030160434103](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20241030160434103.png)

灰色：引起状态转换   橙色：未引起状态转换   蓝色：不合适的消息，直接被服务器端拒绝

LLM生成的客户端请求，69%~89%可以引发状态转移，并覆盖了每个状态的所有状态转移

# LLM指导的协议模糊测试

![图片](https://mmbiz.qpic.cn/mmbiz_png/JchE46RGRlo6If1axsMIkAZ8RoKWFnAgHdGmf3FYVQ1T42ezMoJcRdMftsKTLNicFxG0WqCQaibjPfdFOZA7MkCA/640?wx_fmt=png&from=appmsg&wxfrom=13&tp=wxpic)

这一节主要就是介绍这个LLM引导的模糊测试的算法。灰色部分是本文作者用LLM进行改进的部分：

1. line 2：利用LLM提取语法，并用语法指导模糊测试
2. line 3：丰富种子集
3. line4：突破覆盖率平台期

## 语法指导的变异

本节主要是介绍如何使用LLM来提取语法并用语法来指导需要结构化的变异

### 语法提取：

在让LLM开始来为变异生成语法之前，主要的挑战就是如何获得机器可读的语法。

LLM生成的回应具有相当的灵活性并且是以自然语言的形式呈现的。