# Introduction

本文的目标对象针对JAVA，革新定向模糊测试的现有模式：对于整条调用链的定向测试分解为“逐步”的定向测试。

具体针对的对象是工程项目中的依赖库中的漏洞。当前对于依赖库中漏洞的检测方式为：提取出整个工程项目的依赖树，检查其中是否存在存在漏洞的依赖。

但是这个方法并没有考虑到工程项目中是否实际包含了存在漏洞的库函数，这就会造成很大程度上的假阳性问题

后面为了解决前面说到的这个假阳性的问题，又对整个工程项目构建调用图(CG)，来检查在调用链中是否出现了对应的漏洞函数。但是这个方法无法验证工程项目是不是真的会触发这个漏洞函数，所以也存在假阳性的问题。

后续的，为了解决这个问题，又针对漏洞的触发进行了改进，但是这种方法只能探索触发到项目中直接包含的库中的漏洞函数，并且面对的场景比较简单。

作者提出的这个方法的核心是将对于一整条调用链的定向fuzz拆分成一系列“逐步”的定向fuzz，并以逆向的顺序对拆分出来的每一步进行定向的触发尝试（这里说的逆向是指对于单步的处理从触发库中的漏洞函数开始不断向前直到开始的调用点）。简单的说就是将一个复杂调用链的定向fuzz任务分解为了一些简单相关的单步定向fuzz。

总体上这个magneto分为两步：

1. 首先按正常的漏洞可达性分析来识别所有能够静态到达的到达漏洞函数的调用链。
2. 然后按照这个调用链的逆向顺序对于每一次调用步骤都生成一次exp

magneto会根据前面生成的这些exp啥的来生成一个初始种子

# MOTIVATING EXAMPLE

作者给了个例子：

![image-20250424121310261](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250424121310261.png)

有个调用链式：

Form.validate → Field.validate → Field. getIndexedPropertySize → PropertyUtils.getProperty

从逆方向表示各个函数为F0,F1,F2,F3，这个调用链的存在并不代表这条调用链可以被利用。在指导利用分析是存在两个挑战：

1.如何通过一个可达调用链来评估一个漏洞的可利用性？

漏洞可利用性沿着调用链的传递性。一旦知道调用 F1 时需要满足的参数和接收对象字段状态以触发漏洞，那么通过 F2 利用漏洞的关键就是确保 F2 调用 F1 时能够达到同样的状态。同样，通过 F3 利用漏洞的关键就是确保 F3 调用 F2 时能够达到同样的状态。从最接近漏洞的函数开始，逐步确定上层调用函数所需的输入（参数和接收对象状态），最终构建一个完整的调用序列来触发深层嵌套的漏洞。

2.如何在一个可达调用链中有效的满足潜在复杂的控制流和数据流条件来利用一个漏洞

满足对于各个函数的利用需要保证控制流和数据流满足一定的条件的，并且如果出现多个分支则每个分支需要的触发条件不尽相同

尝试利用 LLMs 的能力，并结合静态和动态分析，来解决通过调用链触发漏洞时遇到的这些复杂约束问题。

# APPROACH

![image-20250424161948168](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250424161948168.png)

首先对工程项目做下简单的漏洞可达性分析，大概就是抽取依赖树构建调用关系图，找到对漏洞位置可达的调用链Fn → Fn−1 → ... → F0，这里顺序是逆向的，F0是目标漏洞函数位置

对于这个调用链中的每一步调用步骤都采用逐步的大模型加持的定向fuzz

对于每一步，其exp都是从之前调用步骤中分析或直接由漏洞数据集提供。

比如说对于Fi-1以及他的exp，magneto提取触发F0中漏洞所需要满足的项目状态。该程序状态包括调用 Fi 的接收者对象和传递给调用 Fi 的参数以及它们流向 Fi-1 的数据。然后magneto联合这个exp上下文以及前面生成的种子模板来生成出一个可以从Fi以触发F0中漏洞所需要的状态执行到Fi-1的种子。

从Fi执行到Fi-1可能需要一些潜在的复杂数据流，前面合成出来的种子可能会失败，但是这只是一个初始种子，后面会通过定向fuzz 的方法来引导这个种子朝能满足所需状态的方向变异。作者使用的定向fuzz实现了一种名为混合行反馈定向fuzz。

## Vulnerability Reachability Analysis

这个步骤主要是为了提取出能够到达漏洞函数的所有可达路径

### Vulnerability Database

这个组件提供了所有依赖库中有关漏洞的基础知识。这是现在所有分析方法都所需要的。对于每一个漏洞，作者将收集：含有该漏洞的所有依赖、在依赖库中含有该漏洞的具体函数、以及对于这个漏洞exp以及相应的oracle。这个要素被作者表示为Vdep、Vf、Vexp、Voracle。在漏洞可党性分析中暂时只需要用到Vdep和Vf。

### Vulnerability-Aware Dependency Tree Construction

在这个步骤中，作者使用Maven的相关命令来提取目标项目的依赖树。由于只考虑项目直接使用到的依赖库，所以这里会用DFS对提取出来的产生的依赖树进行修剪。当遇到Vdep中的依赖库时，从root节点（也就是目标项目）开始到这个依赖库的路径就会被记录。在完成所有的修剪过后得到的这个结果就被记录为Vtree。

### Call Graph Generation

用一个叫做Soot的工具来完成调用图的提取

### Reachable Call Chain Identification

就是从调用图中识别出能够到达Vf中漏洞函数的路径（还是使用的DFS）

## Exploit Context Extraction

对于每一步⟨Fi, Fi−1⟩ ，第一步就是从Fi-1的exp（也就是Vexp中的内容）中提取出exp上下文。这个exp上下文包括从Fi-1执行到F0所需要的程序状态。

作者将这个exp上下文表示为一个三元组：⟨Fi−1, AFi−1, RFi−1 ⟩：其中AFi−1是指在exp中传入给Fi-1的参数， RFi−1是指Fi-1被调用到时的**receiver object（接收对象）**

tips：当一个实例方法（非静态方法）被调用时，该方法所属的对象实例即为 **receiver object**。例如，在 Java 中，若调用 `obj.method()`，则 `obj` 是 `method()` 的接收对象。

如果这个Fi-1是一个构造函数或者静态函数的话，这个 RFi−1就是空集。也就是说，当调用条件满足由RFi−1调用Fi-1，并传入AFi-1的参数时，可以满足触发F0中漏洞的条件。

为了提取到这个CFi-1，作者使用ASM在每一个Fi-1的函数体开始的位置上插桩。如果Fi-1是一个构造函数或者是一个静态函数，那么这个插桩的代码只收集传入这个函数的参数。对于其他的就记录参数和接受对象。

## Seed Template Generation

第二步是通过LLM来生成一个代码模板，来保证Fi-1可以包含在Fi之中。理论上讲，调用Fi时所需要的接受对象和传递给Fi的接受对象和参数存在一些数据流上的关系。也就是说，调用 `Fi-1` 的表达式是基于调用 `Fi` 时的接收对象和参数派生出来的。这种关系被称为 **种子模板（seed template）**，用 `T⟨Fi,Fi−1⟩` 表示。直接使用静态分析来找到这个模板是很困难的，所以作者在这里采用了LLM来推测这个模板的一部分。

作者的提示词为：

​                                     ![image-20250425160435705](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250425160435705.png)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

实际功能上其实就是传入包含Fi-1和Fi调用关系的代码片段，让LLM来推测这个调用关系中所需要的参数类型和个数这些信息，下面是一个LLM返回的例子：

![image-20250425164213162](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250425164213162.png)

这就是对前面程序中F1到F0这个调用的参数类型推测。这里LLM返回的信息中可以看到LLM推测其接受对象需要满足的字段条件，比如这里接受对象需要的字段属性就是java.lang.String，其值就是一个不为空的字符串。然后他所需要的参数类型就是java.util.Map，其值是一个字典格式的返回，里面包含了每个值所对应的类型和value。

这里为了生成焦点代码的可靠性，作者对代码片段做了剪裁，裁去了代码中的无关代码。这里焦点代码是指在Fi调用Fi-1的过程中被使用到的类中的函数和字段。

这里作者使用JD-Core反编译包含Fi的JAR包，然后使用JavaParser来剪裁Fi的代码只留下最后一次Fi调用Fi-1前的语句，这个部分记作Fi~

然后使用ASM工具提取Fi~中所有的函数和字段，将它们分别加入PF和PA之中。同时将所有的函数初始化为一个搜索队列Q，对这个Q执行BFS：

每一次从Q中取出一个Fk，如果这个Fk与Fi在同一个包中，使用ASM提取Fk 中的使用到的所有函数和字段加入PF和PA中。之后将这个Fk使用到的函数加入Q中继续执行BFS直至Q为空后结束。设置BFS的最大深度为2，防止放进去太多的函数。

然后根据这里收集到的PA和FA来裁剪其原始类代码（包含PA和FA中的函数以及字段的那些类），只保留PA和FA中包含的函数和字段，然后将这个被裁剪后的类代码与Fi~做融合得到最后所需要的焦点代码

## Initial Seed Synthesis

这个步骤就是将前面生成的CFi-1与T⟨Fi,Fi−1 ⟩结合生成最后可使用的种子，这个种子记为SFi，其组成是一个四元组：⟨Fi, AFi  , RFi  , Score⟩,这里的Score是后面具体模糊测试中的适配度评分。

从LLM 处获得的那个JSON格式的种子模板可以理解为`SFi.AFi` 和 `SFi.RFi` 的一种“序列化”结果。所以可以通过一种反序列化过程来实例化`SFi.AFi` 和 `SFi.RFi`。种子模板中被符号化的参数值也会被替换为`SFi.AFi` 中的具体值。

由于LLM生成的模板可能有些部分是不完整的，所以需要用点静态分析的手段来修复下，具体怎么修复的没看懂。

这一步就是结合前面的那些信息生成了一个可以实际调用的Java对象

## Hybrid Feedback Directed Fuzzing

作者把初始种子中的变量分为三类：

1. 触发相关变量：与接收对象或Fi-1调用中的参数有数据流关系的变量
2. 控制流相关变量：对Fi-1可达性有影响的变量
3. 其他变量

对于第一个，作者用过程间字段不敏感的污点分析来识别（Mexp），对于第二个作者将那些控制流语句中的变量标记为污点来识别（Mctl），剩下的就是第三类的。

如果一个变量同时属于Mexp和Mctl，则归类到Mexp中。这些信息用于后面fuzz过程变异的反馈

### Fitness Score of Seed

这个评分主要根据执行路径的反馈。

作者通过JaCoCo进行插桩来收集测试样例所执行的行数，在反馈上，如果某个样例的执行路径更靠近Fi-1被调用的位置，则认为这个样例更加接近目标位置。作者将这个分数的具体计算定义为：

![image-20250427101046787](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250427101046787.png)

τ (S)是指种子S覆盖到的行号，lFi−1是指Fi-1被调用的行号，d (l, lFi−1 )代表一个行号与目标行号之间的距离。这个分数算出来越小的测试样例会被分配更多的能量。

### Mutation Strategy

对前面提到的不同类型的变量采取了不同的变异措施。如果变量是Mctl，则给其分配更多的能量，如果变量是Mexp，由于这些变量与在初始种子中大概率都已经构建好了，所以这里给他分配较低的能量，对于Mother，则不分配能量。对于不同的变量类型采用不同的变异方法，大概的策略上其实就两种，变异已有的和生成新的

# EVALUATION

实验部分主要回答三个问题：效果如何、效率如何、消融实验

主要对别三个工具：Siege、Transfer、Vesta

对于RQ1的实验设置为：不单看每个工具能触发的漏洞数量，也看每个工具产生可用exp的能力。为了做对比，作者人工编写了每个含有漏洞的库与被测项目之间的一个可用exp。

对于RQ2的实验设置为：测量作者的工具和其它工具之间在产生每对漏洞与被测项目间可用exp所消耗的时间。

对于RQ3的实验设置：作者设计了几个更改了核心部件的工具，有讲GPT4换成GPT3的，有移除了种子模板生成的和移除了定向fuzz的以及移除了静态分析（代码修剪和初始化种子合成中的一部分）的和种子合成的。

作者设置了几个指标来量化实验结果：

- EPN:表示成功生成了exp的漏洞和被测项目对的数量
- ECN表示成功生成exp的调用链数量
- MEL表示所有可被利用的调用链中被利用了的链条的最大值
- AEL表示所有可被利用的调用链中被利用了的链条的平均值

## RQ1

![image-20250427111831455](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250427111831455.png)

数据并不是很好看，对于有些漏洞是生成失败了，作者分析失败原因是由于在提取焦点代码时由于有些复杂的功能包含了太多函数导致LLM理解产生了困难或者是有些用了太多的第三方库导致其上下文很少都会使LLM的理解产生困难。

![image-20250427112413834](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250427112413834.png)

这是在生成了exp的调用链中各个长度的调用链数量，可以看出这个工具可以触发一些更加比较复杂的调用链，证明作者说的这个在复杂情况下的性能更好。

## RQ2

![image-20250427112807668](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250427112807668.png)

在耗时上看起来就比较一般，作者说是因为他这个工具多了些步骤

## RQ3

![image-20250427112952028](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20250427112952028.png)·

通过消融实验可以看到这个工具受LLM性能的影响还是比较大

其它几个组件均有影响。但是生成焦点代码时使用的代码修剪所设置的BFS深度的影响并不大