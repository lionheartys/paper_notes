# 距离计算

## 一些疑问和解答

我按照AFLGO的距离计算为基础来进行理解，按照常理来说，在静态分析中进行的距离计算应该是每个函数或是基本块到目标函数或基本块的距离。在AFLGO的设计中，基本块在跨函数时会被会被固定设置一个惩罚系数，这个惩罚系数就被设置为一个默认值：每层函数跳转10（也就是师兄论文中出现的那个无法分辨长短种子的问题）

所谓的无法分辨长短种子的问题就是指：

假如我们有两个种子，一个种子的输入是：AB，它能触发：main() → parse_input() → check_A() （停了）的路径；另一个种子是：ABCDEFG，它可能经过少量编译就可以触发路径：main() → parse_input() → check_A() （二号种子最开始停在这里）→ process() → validate() → vuln() 。

**但是**：AFLGO只会取跟目标位置最近的基本块来给种子打分，所以在这个地方这两个种子在AFLGO的得分计算模式下得到的分是一样的，其获得的能量也是一样的，那么本质上更有可能到达目标位置的二号种子就没有分配到更多能量。

另外的，在AFLGO的逻辑下，它会对目标程序中的所有基本块或函数进行其到目标函数或基本块的距离计算，这就对应了各个论文中说的：它的距离计算对象是整个代码空间，这会导致有大量的与触发目标无关的距离计算。

现在大部分的对于定向fuzz的研究原型都是基于AFLGO这套“距离”的模型，一个研究的重心就是如何对这个距离计算的体系进行优化，从而更好的引导fuzzer

在静态分析中可能会面临一些由非直接调用引起的调用关系缺失，比如通过函数指针进行的函数调用是不会直接在获得CG或CFG中体现出来的，这里一般都是采用一种传统的叫做：Andersen’s points-to analysis的方法来完成的。这种方法基于约束求解的静态指针分析，简单来说就是分析程序中的指针可能指向的对象。

## 一些关键概念的理解

在论文中可以看到一个叫做：deviation basic blocks的东西，按照我的理解这个东西应该叫做偏移基本块，他在程序中表现为分支语句，比如说if。当程序运行到此处时可能会出现的由于不满足某些条件而造成执行流发生偏移。所以在有些定向fuzzer中会对这种偏移基本块做些处理来防止它对到达目标位置产生影响（windranger）。

在静态分析处理中会用到的前后向分析可以这样理解：前向分析可以找到完整的调用链，后向分析可以找到所有与目标位置相关的函数或基本块（即是这个函数或基本块并不是一个传统意义上的入口函数）

AFLGO中的距离计算大概是这么个样式：

```c
di += 1.0 / (1.0 + 10 * bb_d + shortest)
```

这个bb_d就是跨函数跳转的次数，这个10就是设置的在函数间跳转时的固定开销，这个shortest是通过迪杰斯特拉算法算出来的在本函数CFG中入口点到callist或者target的最短距离

对于前面提到的这个函数间距离固定值的问题，其实可以将函数入口点基本块与产生函数调用基本块之间的距离视为函数间的距离。

