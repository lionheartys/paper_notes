# 距离计算

## 一些疑问和解答

我按照AFLGO的距离计算为基础来进行理解，按照常理来说，在静态分析中进行的距离计算应该是每个函数或是基本块到目标函数或基本块的距离。在AFLGO的设计中，基本块在跨函数时会被会被固定设置一个惩罚系数，这个惩罚系数就被设置为一个默认值：每层函数跳转10（也就是师兄论文中出现的那个无法分辨长短种子的问题）

所谓的无法分辨长短种子的问题就是指：

假如我们有两个种子，一个种子的输入是：AB，它能触发：main() → parse_input() → check_A() （停了）的路径；另一个种子是：：ABCDEFG，它可能经过少量编译就可以触发路径：main() → parse_input() → check_A() （二号种子最开始停在这里）→ process() → validate() → vuln() 。

**但是**：AFLGO只会取跟目标位置最近的基本块来给种子打分，所以在这个地方这两个种子在AFLGO的得分计算模式下得到的分是一样的，其获得的能量也是一样的，那么本质上更有可能到达目标位置的二号种子就没有分配到更多能量。

另外的，在AFLGO的逻辑下，它会对目标程序中的所有基本块或函数进行其到目标函数或基本块的距离计算，这就对应了各个论文中说的：它的距离计算对象是整个代码空间，这会导致有大量的与触发目标无关的距离计算

## 一些关键概念的理解

在论文中可以看到一个叫做：deviation basic blocks的东西，按照我的理解这个东西应该叫做偏移基本块，他在程序中表现为分支语句，比如说if。当程序运行到此处时可能会出现的由于不满足某些条件而造成执行流发生偏移。所以在有些定向fuzzer中会对这种偏移基本块做些处理来防止它对到达目标位置产生影响（windranger）。

在静态分析处理中会用到的前后向分析可以这样理解：前向分析可以找到完整的调用链，后向分析可以找到所有与目标位置相关的函数或基本块（即是这个函数或基本块并不是一个传统意义上的入口函数）

对于前面提到的AFLGO中对于