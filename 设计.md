# prompt

现在的prompt只针对于libxml这一个库，我需要进行一些修改使其支持其它的开源库

```python
CODE_GENERATE_PROMPT = """
        You are an expert in fuzz testing and you are testing an open source library called %s,please write a fuzz harness that could trigger the target function named "%s" in this open source library\
        Here is some data about this library to help you complete the harness generation: \
        1. This is a call chain that include the target function: %s \
        2. This target function is declared or used in %s in the source code of this library. \
        These information may be helpful when you generate the fuzz harness. \
        The harness you gernerate should include the libxml2 library and complie successfully. \
        
        Format requirements : The code should follow the C or C++ code specification, and the program code should be complete and properly formatted.
        In the code, you should write a long sentence without using line breaks, avoiding the newline character \ n.
        Try not to use 'printf' in generated code. Don’t make up APIs that don't exist.

        Here is an example. You can refer to its format. \
        It is just a sample template and does not need to be strictly followed. \
        Your core goal is to complete the triggering of the call chain. \
        
        #include <stdio.h>
        #include <stdlib.h>

        /* ===== Abstraction Layer ===== */
        /* Example placeholder for encoding conversion */
        char* convert_encoding(const char* input) {
            // Replace with actual encoding/normalization logic if needed
            return (char*)input;
        }

        /* ===== Initialization ===== */
        void library_init() {
            // Call the target library’s init function if required
        }

        /* ===== Resource Container Declaration ===== */
        typedef struct {
            void* doc;       // Document or main object
            void* root;      // Root or primary node
        } Context;

        /* ===== Main Operations ===== */
        Context* create_new_context() {
            Context* ctx = malloc(sizeof(Context));
            if (!ctx) return NULL;

            // Replace with library-specific allocation / constructor
            ctx->doc  = /* library_new_document("version") */ NULL;
            ctx->root = /* library_new_node(convert_encoding("root")) */ NULL;

            // Example of setting root
            // library_set_root(ctx->doc, ctx->root);

            return ctx;
        }

        Context* parse_existing_context(const char* filename) {
            // Replace with actual library parse function
            Context* ctx = malloc(sizeof(Context));
            if (!ctx) return NULL;

            ctx->doc = /* library_parse_file(filename) */ NULL;
            ctx->root = /* library_get_root(ctx->doc) */ NULL;
            return ctx;
        }

        void operate_on_context(Context* ctx) {
            if (!ctx || !ctx->root) return;

            // Example: create child node
            // library_add_child(ctx->root, convert_encoding("child"), convert_encoding("content"));

            // Example: set attribute
            // library_set_attribute(ctx->root, convert_encoding("attr"), convert_encoding("value"));
        }

        void persist_context(Context* ctx, const char* out_file) {
            if (!ctx || !ctx->doc) return;
            // Replace with actual save/export function
            // library_save(ctx->doc, out_file, "UTF-8");
        }

        /* ===== Cleanup ===== */
        void cleanup_context(Context* ctx) {
            if (!ctx) return;
            if (ctx->doc) {
                // library_free_document(ctx->doc);
            }
            free(ctx);
        }

        void library_cleanup() {
            // Call the target library’s global cleanup function if required
        }

        /* ===== Entry Point ===== */
        int main() {
            library_init();

            Context* ctx = create_new_context();
            // Alternatively: ctx = parse_existing_context("input.file");

            if (ctx) {
                operate_on_context(ctx);
                persist_context(ctx, "output.file");
                cleanup_context(ctx);
            } else {
                fprintf(stderr, "Context initialization failed\n");
            }

            library_cleanup();
            return EXIT_SUCCESS;
        }


        When you finish the code generation, please give me the compile command. In the compile command you give, use a.c to refer to the code, and a.out to execution file,\
        and make sure the compile command can compile the code successfully. \
        
        Your answer needs to be in json format containing two properties: code and compile_command. 
        """

HARNESS_FIX = """
        You are a code repair expert. \
        The code I give you had encountered some problems during compilation. \
        The code that encountered the problem is as follows: \
        %s \
        The compile command last time you give me that I use to compile the code is as follows: \
        %s \
        The error message is: \
        %s \
        
        Now you need to modify the code or compile command I gave you to fix the problem it encountered. \
        
        If there is a problem such as "No such file or directory" in the compilation error caused by the relevant library not being found, \
        give priority to using tools such as pkg-config to repair the compilation command. \
        
        When you finish the code or compile command modification, please give me the result. \
        In the compile command you give, use a.c to refer to the code, and a.out to execution file,\
        and make sure the compile command can compile the code successfully. \
        
        Your answer needs to be in json format containing two properties: code and compile_command. \
"""
```

# main

之前程序的设计是以git仓库为基础来设计的 ，但是后面面对的目标不一定是git仓库，这一块要重构一下。

重新设置了参数构成，现在取消了之前按照git仓库设计的通过commit编号来获取变动的操作，现在只需要提供目标函数名称。

后续可能要设计一下通过文件和行确定目标函数的功能。

# extract_the_call_chain

现在的主要问题是：修改了调用链提取逻辑，现在的提取逻辑会将所有可达的调用链提取出来，最后valid_paths中会有过多的路径，我现在需要对这些路径进行一些筛选

现在的第一个问题是，一次性遍历出所有的可达路径太慢了，我需要对这个调用链提取进行一些优化：

现在的思路是：

1. 首先使用反向的DFS找到目标函数的可达根节点（缩小搜索空间） 
2. 找到的根节点我首先在图中找到它的label（一般是函数名），然后让大模型给我筛选出可能可以作为harness编写的入口点 
3. 对于筛选剩下的root节点，我每个节点选取一条调用链，中间加入长度限制（我暂时不知道限制调用链长度为多少合适，暂定为5到7这个范围内），这样一次性会形成一个batch，但是其余没有选择的调用链仍然有不可忽视的可能的利用价值，所以我需要在后面（也就是如果这一次的batch没有生成有价值的harness的话），在这些剩下的路径中再构建下一个batch来进行生成



现在我已经获得了一些筛选后的API入口，现在对于这些入口抽取调用链，抽取的规则先限定为每个节点一条，且这条调用链的长度限制在5-7之间。

# batch管理

1. 关于 **batch 管理**

现在每一批 harness 都是基于调用链生成的，而后续需要根据 fuzz 反馈来判断这个 batch 的效果。
 所以 batch 管理至少需要维护：

- **batch 的唯一标识**（batch_id）
- **该 batch 中使用的调用链集合**（避免重复）
- **该 batch 的 fuzz 执行结果**（覆盖率、崩溃/超时/异常数量等）
- **该 batch 的评分指标**

这意味着调用链本身以及 batch 的整体表现都要持久化，否则后续你没法保证：

- 新生成的 batch 没有重复用过的调用链。
- 可以回溯对比不同 batch 的效果，形成迭代改进。

所以我的建议是：**调用链 + batch 信息必须持久化**，可以考虑存储成 JSON 或 SQLite（推荐 SQLite，方便做查询和去重）。

------

2. 关于 **反馈信息**

基于 aflgo 的定向 fuzz，反馈信息可以分几类：

1. **覆盖率类指标**
   - 到达目标函数的次数
   - 到达目标函数路径的多样性（不同调用链是否被覆盖）
   - 新增边数、新增基本块数
2. **执行表现类指标**
   - 执行总次数 / 执行速度（exec/sec）
   - 输入文件数的增长情况（是否持续有新 test case）
3. **异常类指标**
   - crash 数量（segfault、heap overflow、use-after-free 等）
   - hang/timeout 数量
4. **定向 fuzz 特有指标**（aflgo 的 distance-based scheduling）
   - distance 值分布（有没有趋近目标函数）
   - harness 输入是否真的让 distance 值降低

> 如果你一开始没办法全收集，可以先从 **覆盖率（目标函数是否被 hit）** 和 **crash 数量** 这两个最直观的指标入手。

------

3. 关于 **评分机制**

有了反馈信息，可以构造一个 batch-level score，比如：

```
Score = α * coverage + β * new_paths + γ * unique_crashes - δ * timeouts
```

其中 α/β/γ 是权重参数，你可以根据任务目标来调，比如如果主要目的是到达目标函数，那 α 高一点；如果是发现 bug，那 β 高一点。

------

4. 关于 **batch 演进**

- **避免重复**：你在生成新 batch 时，从数据库中过滤掉已经用过的调用链。
- **动态调整策略**：比如，如果前一个 batch 表现差，可以尝试：
  - 增加调用链长度的多样性
  - 更换 root_api 的优先级
  - 引入更多不同的路径
- **探索 vs 利用**：类似强化学习，需要平衡“继续利用已经表现好的调用链”和“尝试新链路”之间的关系。

信息固化现在尝试使用SQLite来做

现在的 **核心设计关系** 是：

```
Root API  <->  Call Chain  <->  Harness  <->  Score (fuzz feedback)
```

再加上 **信息固化（SQLite/文件等）**，形成一个 `Batch` 类框架：

## batch的创建

在运行逻辑中，batch的首次创建是没有fuzz相关的反馈信息，所以batch中与fuzz相关的信息部分是None，这些信息会在后面被补全

第一次创建的batch类以及保存进json文件的信息只有target_func与其生成的harness相关的东西。

由于将batch_id作为了唯一的标识符，所以在后面fuzz产生反馈之后，通过id索引到相关的batch上，再将反馈信息填充回去

# fuzz反馈

现在的三个比较核心的问题是：

1. 需要什么反馈
2. 如何处理反馈
3. 反馈应该如何作用域harness的生成（或者是harness的筛选与调整）

